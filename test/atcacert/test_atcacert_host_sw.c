/**
 * \file
 * \brief Tests for host side software crypto methods
 *
 * \copyright (c) 2020-2025 Microchip Technology Inc. and its subsidiaries.
 *
 * \page License
 *
 * Subject to your compliance with these terms, you may use Microchip software
 * and any derivatives exclusively with Microchip products. It is your
 * responsibility to comply with third party license terms applicable to your
 * use of third party software (including open source software) that may
 * accompany Microchip software.
 *
 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
 * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
 * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
 * PARTICULAR PURPOSE. IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT,
 * SPECIAL, PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE
 * OF ANY KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF
 * MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE
 * FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL
 * LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED
 * THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR
 * THIS SOFTWARE.
 */
#include "atca_test.h"
//Run the tests when either of OpenSSL/MbedTLS/WolfSSL is enabled
#if ATCA_HOSTLIB_EN
#include "atcacert/atcacert_host_sw.h"
#include "atca_basic.h"
#include "test_cert_def_0_device.h"
#include "test_cert_def_1_signer.h"
#include "test_cert_def_13_signer.h"
#include "test_cert_def_14_device.h"
#include <string.h>

static const uint8_t g_signer_cert[] = {
    0x30, 0x82, 0x01, 0xB0, 0x30, 0x82, 0x01, 0x57, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x03, 0x40,
    0xC4, 0x8B, 0x30, 0x0A, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x02, 0x30, 0x36,
    0x31, 0x10, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x0C, 0x07, 0x45, 0x78, 0x61, 0x6D, 0x70,
    0x6C, 0x65, 0x31, 0x22, 0x30, 0x20, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x19, 0x45, 0x78, 0x61,
    0x6D, 0x70, 0x6C, 0x65, 0x20, 0x41, 0x54, 0x45, 0x43, 0x43, 0x35, 0x30, 0x38, 0x41, 0x20, 0x52,
    0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x30, 0x1E, 0x17, 0x0D, 0x31, 0x34, 0x30, 0x38, 0x30, 0x32,
    0x32, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5A, 0x17, 0x0D, 0x33, 0x34, 0x30, 0x38, 0x30, 0x32, 0x32,
    0x30, 0x30, 0x30, 0x30, 0x30, 0x5A, 0x30, 0x3A, 0x31, 0x10, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x04,
    0x0A, 0x0C, 0x07, 0x45, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x31, 0x26, 0x30, 0x24, 0x06, 0x03,
    0x55, 0x04, 0x03, 0x0C, 0x1D, 0x45, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x20, 0x41, 0x54, 0x45,
    0x43, 0x43, 0x35, 0x30, 0x38, 0x41, 0x20, 0x53, 0x69, 0x67, 0x6E, 0x65, 0x72, 0x20, 0x43, 0x34,
    0x38, 0x42, 0x30, 0x59, 0x30, 0x13, 0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x02, 0x01, 0x06,
    0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07, 0x03, 0x42, 0x00, 0x04, 0x8B, 0x59, 0x97,
    0xE6, 0x3A, 0xD2, 0x18, 0xBF, 0xE6, 0x19, 0xD7, 0x42, 0x17, 0xD8, 0xA7, 0x79, 0x7E, 0xD4, 0x41,
    0xA8, 0x9C, 0x5E, 0x7E, 0x13, 0xAD, 0x7D, 0xA1, 0xBF, 0xA7, 0x71, 0x31, 0x6F, 0xD4, 0xFE, 0x6A,
    0x6A, 0xCD, 0x1D, 0x94, 0x3A, 0x07, 0xCD, 0x3D, 0x7D, 0xD2, 0x0C, 0xCF, 0xF6, 0xCA, 0x04, 0xFC,
    0xBC, 0x15, 0xE8, 0x6C, 0x26, 0x39, 0xE0, 0x1F, 0xAA, 0x6C, 0xA0, 0x4A, 0x12, 0xA3, 0x50, 0x30,
    0x4E, 0x30, 0x0C, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xFF, 0x30,
    0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0xD9, 0x69, 0xCE, 0x9C, 0xE4, 0x33,
    0xEF, 0x2A, 0xEF, 0xCC, 0xD8, 0x62, 0x72, 0x4A, 0x49, 0xA2, 0x1B, 0x17, 0xE5, 0xD3, 0x30, 0x1F,
    0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0xFB, 0x17, 0xB4, 0x6A, 0x07,
    0xCC, 0xCE, 0x70, 0xF5, 0xF7, 0xC2, 0xD7, 0x8D, 0xDD, 0x62, 0x1A, 0x12, 0xF0, 0x9C, 0xD3, 0x30,
    0x0A, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x02, 0x03, 0x47, 0x00, 0x30, 0x44,
    0x02, 0x20, 0x29, 0x09, 0xF2, 0xE2, 0xE5, 0xB1, 0xF0, 0xF1, 0xE5, 0x37, 0x90, 0x9A, 0x4D, 0x0D,
    0xCB, 0x38, 0x23, 0x0E, 0xE8, 0x5D, 0xC8, 0xF8, 0xAC, 0x07, 0x65, 0x22, 0x9E, 0x11, 0xC3, 0x95,
    0xD7, 0x96, 0x02, 0x20, 0x13, 0xBC, 0x35, 0x0A, 0x93, 0x95, 0xE8, 0xFF, 0x08, 0xFD, 0xEC, 0x51,
    0x11, 0x8D, 0xD0, 0x5F, 0xBD, 0x95, 0xE9, 0x81, 0x92, 0xB3, 0x76, 0x5D, 0xC2, 0xD4, 0xF4, 0x40,
    0xEB, 0x81, 0xE7, 0xF5
};

static const uint8_t g_device_cert[] = {
    0x30, 0x82, 0x01, 0x8A, 0x30, 0x82, 0x01, 0x30, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x0A, 0x40,
    0x01, 0x23, 0x83, 0x32, 0xD9, 0x2C, 0xA5, 0x71, 0xEE, 0x30, 0x0A, 0x06, 0x08, 0x2A, 0x86, 0x48,
    0xCE, 0x3D, 0x04, 0x03, 0x02, 0x30, 0x3A, 0x31, 0x10, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x04, 0x0A,
    0x0C, 0x07, 0x45, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x31, 0x26, 0x30, 0x24, 0x06, 0x03, 0x55,
    0x04, 0x03, 0x0C, 0x1D, 0x45, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x20, 0x41, 0x54, 0x45, 0x43,
    0x43, 0x35, 0x30, 0x38, 0x41, 0x20, 0x53, 0x69, 0x67, 0x6E, 0x65, 0x72, 0x20, 0x43, 0x34, 0x38,
    0x42, 0x30, 0x1E, 0x17, 0x0D, 0x31, 0x35, 0x30, 0x39, 0x30, 0x33, 0x32, 0x31, 0x30, 0x30, 0x30,
    0x30, 0x5A, 0x17, 0x0D, 0x33, 0x35, 0x30, 0x39, 0x30, 0x33, 0x32, 0x31, 0x30, 0x30, 0x30, 0x30,
    0x5A, 0x30, 0x35, 0x31, 0x10, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x0C, 0x07, 0x45, 0x78,
    0x61, 0x6D, 0x70, 0x6C, 0x65, 0x31, 0x21, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x18,
    0x45, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x20, 0x41, 0x54, 0x45, 0x43, 0x43, 0x35, 0x30, 0x38,
    0x41, 0x20, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x30, 0x59, 0x30, 0x13, 0x06, 0x07, 0x2A, 0x86,
    0x48, 0xCE, 0x3D, 0x02, 0x01, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07, 0x03,
    0x42, 0x00, 0x04, 0xC7, 0x94, 0x94, 0x6A, 0x0C, 0xCB, 0x54, 0x1E, 0xFE, 0x50, 0x56, 0xA2, 0x93,
    0xC8, 0xC4, 0xC0, 0xC2, 0x41, 0xC1, 0x35, 0x78, 0xDE, 0x98, 0x19, 0x2C, 0x86, 0x11, 0x5F, 0x4E,
    0x98, 0x10, 0x38, 0xF1, 0x93, 0xCB, 0xA4, 0x81, 0x6A, 0xD8, 0x67, 0x04, 0x4E, 0x98, 0x36, 0x95,
    0x7F, 0xD6, 0xF0, 0x03, 0xA9, 0x82, 0x05, 0x3A, 0xD5, 0x5D, 0x99, 0x2A, 0xD0, 0x00, 0x2F, 0x3D,
    0xFB, 0x8B, 0xCE, 0xA3, 0x23, 0x30, 0x21, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18,
    0x30, 0x16, 0x80, 0x14, 0xD9, 0x69, 0xCE, 0x9C, 0xE4, 0x33, 0xEF, 0x2A, 0xEF, 0xCC, 0xD8, 0x62,
    0x72, 0x4A, 0x49, 0xA2, 0x1B, 0x17, 0xE5, 0xD3, 0x30, 0x0A, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE,
    0x3D, 0x04, 0x03, 0x02, 0x03, 0x48, 0x00, 0x30, 0x45, 0x02, 0x20, 0x5B, 0xD0, 0xAE, 0xF5, 0x47,
    0x34, 0x5B, 0x0D, 0x6C, 0xC2, 0x2A, 0xB3, 0x67, 0x5C, 0x80, 0xC9, 0x41, 0x0D, 0x35, 0x07, 0x92,
    0xF3, 0x50, 0x12, 0x15, 0xAC, 0x33, 0xEB, 0x2B, 0x8E, 0xBB, 0x72, 0x02, 0x21, 0x00, 0x8C, 0x81,
    0xB8, 0x27, 0x09, 0x40, 0x91, 0x18, 0xF2, 0xC5, 0x15, 0x73, 0x23, 0x60, 0x42, 0x81, 0xE3, 0x61,
    0x01, 0xE4, 0x58, 0x67, 0x0A, 0x33, 0xF5, 0xDC, 0xB4, 0x0E, 0xC1, 0x60, 0x83, 0x87
};

#if ATCA_TA_SUPPORT && ATCAC_SHA384_EN && ATCAC_SHA512_EN
static const uint8_t g_p521_signer_cert[] = {
    0x30, 0x82, 0x02, 0x25, 0x30, 0x82, 0x01, 0x86, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x03, 0x40,
    0xC4, 0x8B, 0x30, 0x0A, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x02, 0x30, 0x2C,
    0x31, 0x10, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x0C, 0x07, 0x45, 0x78, 0x61, 0x6D, 0x70,
    0x6C, 0x65, 0x31, 0x18, 0x30, 0x16, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x0F, 0x45, 0x78, 0x61,
    0x6D, 0x70, 0x6C, 0x65, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x54, 0x41, 0x30, 0x1E, 0x17, 0x0D,
    0x32, 0x35, 0x30, 0x31, 0x31, 0x38, 0x32, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5A, 0x17, 0x0D, 0x33,
    0x35, 0x30, 0x31, 0x31, 0x38, 0x32, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5A, 0x30, 0x33, 0x31, 0x10,
    0x30, 0x0E, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x0C, 0x07, 0x45, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65,
    0x31, 0x1F, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x16, 0x45, 0x78, 0x61, 0x6D, 0x70,
    0x6C, 0x65, 0x20, 0x54, 0x41, 0x20, 0x53, 0x69, 0x67, 0x6E, 0x65, 0x72, 0x20, 0x43, 0x34, 0x38,
    0x42, 0x30, 0x81, 0x9B, 0x30, 0x10, 0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x02, 0x01, 0x06,
    0x05, 0x2B, 0x81, 0x04, 0x00, 0x23, 0x03, 0x81, 0x86, 0x00, 0x04, 0x01, 0x1B, 0x55, 0x41, 0x63,
    0xB6, 0xD1, 0x66, 0xB9, 0x36, 0x3B, 0x73, 0x79, 0x45, 0xFF, 0x49, 0xE4, 0xA6, 0x72, 0xCC, 0x8C,
    0x28, 0xB5, 0x90, 0xA7, 0xA7, 0x2A, 0x97, 0x37, 0x45, 0x2F, 0x6C, 0x4E, 0x61, 0x65, 0x67, 0x1F,
    0x35, 0x20, 0xAE, 0xFE, 0x53, 0xD2, 0xFD, 0x69, 0x1C, 0xC5, 0x7F, 0x42, 0xEF, 0x4C, 0xE6, 0x67,
    0x1C, 0x31, 0x34, 0xF3, 0xF3, 0xFC, 0x04, 0x13, 0x6F, 0x38, 0x64, 0x2E, 0x01, 0x01, 0x91, 0x0F,
    0x97, 0x44, 0x5F, 0xD7, 0xF7, 0x94, 0x33, 0xDD, 0xCE, 0xBA, 0x18, 0x14, 0x1F, 0x92, 0x13, 0x47,
    0x5D, 0x81, 0xF0, 0x78, 0x07, 0x7B, 0xCE, 0x97, 0x85, 0xEB, 0xEF, 0xF0, 0x47, 0xB9, 0x14, 0x69,
    0x85, 0xF3, 0x78, 0xE4, 0x5D, 0x07, 0xA0, 0x8B, 0xCC, 0xAA, 0x21, 0x8F, 0xEB, 0xBE, 0x5D, 0x3C,
    0x43, 0xEA, 0x46, 0x22, 0xDF, 0x89, 0xB6, 0x93, 0x3B, 0x17, 0xB2, 0x90, 0x9D, 0x41, 0x54, 0xA3,
    0x4D, 0x30, 0x4B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x04, 0x02, 0x30, 0x00, 0x30, 0x1D,
    0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0xC8, 0x69, 0x00, 0x1E, 0x62, 0xAC, 0x04,
    0x36, 0x88, 0xDF, 0xE7, 0xF7, 0xD3, 0x98, 0xF5, 0x10, 0x7C, 0xE0, 0xF4, 0x3D, 0x30, 0x1F, 0x06,
    0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0xC0, 0x11, 0xD2, 0x51, 0x3D, 0xAF,
    0x6B, 0xC0, 0x60, 0xF0, 0x87, 0x36, 0x85, 0xA4, 0xA0, 0x34, 0xE5, 0xDC, 0x33, 0xA3, 0x30, 0x0A,
    0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x02, 0x03, 0x81, 0x8C, 0x00, 0x30, 0x81,
    0x88, 0x02, 0x42, 0x00, 0xAC, 0x64, 0xC2, 0x94, 0xC4, 0x96, 0xFA, 0x55, 0xC1, 0x84, 0x13, 0x46,
    0x2F, 0x25, 0x75, 0x59, 0x9D, 0x8F, 0xF2, 0x23, 0x6B, 0xE7, 0x6A, 0xF8, 0x8C, 0x84, 0x59, 0x40,
    0xA4, 0x43, 0x57, 0x24, 0x1D, 0xA4, 0x0B, 0xFD, 0x67, 0x0F, 0x97, 0xE2, 0x0F, 0x51, 0xB2, 0xBB,
    0xD2, 0x82, 0x57, 0xDF, 0xFA, 0xE5, 0xB6, 0xA2, 0x8F, 0xCC, 0xB3, 0xB9, 0x57, 0x7F, 0xBE, 0x77,
    0xA9, 0x43, 0x3F, 0x08, 0xAF, 0x02, 0x42, 0x01, 0x76, 0x63, 0xEA, 0x63, 0x6B, 0xCF, 0x72, 0x6A,
    0xB9, 0x51, 0x0F, 0xC8, 0x5F, 0xE0, 0x66, 0x82, 0x0F, 0x7E, 0x43, 0x02, 0xFA, 0x4B, 0x5E, 0x2A,
    0xC2, 0xF7, 0x44, 0x3A, 0xCC, 0x5E, 0x93, 0xC6, 0xC0, 0x59, 0xE4, 0x42, 0x72, 0xF7, 0x28, 0x2E,
    0x37, 0x61, 0xC0, 0xFA, 0x51, 0x29, 0xBE, 0xEC, 0x84, 0x06, 0x1D, 0x1F, 0x18, 0x53, 0x8D, 0xA0,
    0xA2, 0x92, 0xCF, 0x91, 0x49, 0x51, 0xA7, 0x50, 0x6B
};
#endif

TEST_GROUP(atcacert_host_sw);

TEST_SETUP(atcacert_host_sw)
{
    int ret = atcab_init(gCfg);
    TEST_ASSERT_EQUAL(ATCA_SUCCESS, ret);
}

TEST_TEAR_DOWN(atcacert_host_sw)
{
    ATCA_STATUS status;

    status = atcab_wakeup();
    TEST_ASSERT_EQUAL(ATCA_SUCCESS, status);

    status = atcab_sleep();
    TEST_ASSERT_EQUAL(ATCA_SUCCESS, status);

    status = atcab_release();
    TEST_ASSERT_EQUAL(ATCA_SUCCESS, status);
}

#if ATCAC_VERIFY_EN
TEST(atcacert_host_sw, test_atcacert_verify_cert_sw_success)
{
    int ret = 0;
    uint8_t signer_public_key[ATCA_ECCP256_PUBKEY_SIZE];
    cal_buffer test_signer_1_ca_public_key = CAL_BUF_INIT(ATCA_ECCP256_PUBKEY_SIZE, g_test_signer_1_ca_public_key);
    cal_buffer signer_pubkey = CAL_BUF_INIT(sizeof(signer_public_key), signer_public_key);

    // Validate signer cert against its certificate authority (CA) public key
    ret = atcacert_verify_cert_sw(&g_test_cert_def_1_signer, g_signer_cert, sizeof(g_signer_cert), &test_signer_1_ca_public_key);
    TEST_ASSERT_EQUAL(ATCACERT_E_SUCCESS, ret);

    // Get the signer's public key from its certificate
    ret = atcacert_get_subj_public_key(&g_test_cert_def_1_signer, g_signer_cert, sizeof(g_signer_cert), &signer_pubkey);
    TEST_ASSERT_EQUAL(ATCACERT_E_SUCCESS, ret);

    // Validate the device cert against its certificate authority (CA) which is the signer
    ret = atcacert_verify_cert_sw(&g_test_cert_def_0_device, g_device_cert, sizeof(g_device_cert), &signer_pubkey);
    TEST_ASSERT_EQUAL(ATCACERT_E_SUCCESS, ret);
}

TEST_CONDITION(atcacert_host_sw, verify_chain_cond)
{
    ATCADeviceType dev_type = atca_test_get_device_type();

    return (TA101 == dev_type);
}

#if ATCA_TA_SUPPORT && ATCAC_SHA384_EN && ATCAC_SHA512_EN
TEST(atcacert_host_sw, test_atcacert_verify_cert_sw_p521_signer_p384_device)
{
    int ret = 0;
    uint8_t signer_public_key[ATCA_ECCP521_PUBKEY_SIZE];
    cal_buffer test_p521_signer_13_ca_public_key = CAL_BUF_INIT(ATCA_ECCP521_PUBKEY_SIZE, g_test_p521_signer_13_ca_public_key);
    cal_buffer signer_pubkey = CAL_BUF_INIT(sizeof(signer_public_key), signer_public_key);
    static const uint8_t p384_device_cert[] = {
        0x30, 0x82, 0x02, 0x0E, 0x30, 0x82, 0x01, 0x6F, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x09, 0x40,
        0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x30, 0x0A, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE,
        0x3D, 0x04, 0x03, 0x02, 0x30, 0x33, 0x31, 0x10, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x0C,
        0x07, 0x45, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x31, 0x1F, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x04,
        0x03, 0x0C, 0x16, 0x45, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x20, 0x54, 0x41, 0x20, 0x53, 0x69,
        0x67, 0x6E, 0x65, 0x72, 0x20, 0x43, 0x34, 0x38, 0x42, 0x30, 0x1E, 0x17, 0x0D, 0x32, 0x35, 0x30,
        0x31, 0x32, 0x30, 0x32, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5A, 0x17, 0x0D, 0x33, 0x35, 0x30, 0x31,
        0x32, 0x30, 0x32, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5A, 0x30, 0x35, 0x31, 0x10, 0x30, 0x0E, 0x06,
        0x03, 0x55, 0x04, 0x0A, 0x0C, 0x07, 0x45, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x31, 0x21, 0x30,
        0x1F, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x18, 0x45, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x20,
        0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x43, 0x65, 0x72, 0x74, 0x20, 0x58, 0x58, 0x58, 0x58,
        0x30, 0x76, 0x30, 0x10, 0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x02, 0x01, 0x06, 0x05, 0x2B,
        0x81, 0x04, 0x00, 0x22, 0x03, 0x62, 0x00, 0x04, 0x23, 0xE8, 0xAD, 0xF0, 0xB8, 0x79, 0x30, 0xA5,
        0x0D, 0xD3, 0x6D, 0x0F, 0xFB, 0x4B, 0xFD, 0x94, 0x76, 0xC0, 0xC6, 0x9F, 0x6B, 0x42, 0x2F, 0x85,
        0xEC, 0x08, 0x5C, 0xFB, 0xB7, 0xBC, 0xE1, 0x73, 0xFC, 0xAE, 0xF5, 0x70, 0x96, 0xD9, 0xDF, 0x2D,
        0xD6, 0x25, 0xAF, 0xA7, 0xA1, 0x96, 0xAA, 0x0D, 0xE0, 0x1A, 0x21, 0x21, 0x2F, 0x94, 0xF9, 0x09,
        0xE5, 0x90, 0x22, 0xFD, 0xE3, 0x66, 0xA4, 0x02, 0x8C, 0xAF, 0x81, 0x8C, 0x33, 0x80, 0xFF, 0x92,
        0xCF, 0x6A, 0xA7, 0x95, 0x6B, 0x2C, 0x78, 0xA6, 0xE2, 0xB1, 0x35, 0xDE, 0x47, 0x48, 0x1B, 0xEE,
        0x05, 0xE1, 0x62, 0x1D, 0xE9, 0x79, 0x76, 0xC2, 0xA3, 0x4D, 0x30, 0x4B, 0x30, 0x09, 0x06, 0x03,
        0x55, 0x1D, 0x13, 0x04, 0x02, 0x30, 0x00, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16,
        0x04, 0x14, 0x93, 0x09, 0x1C, 0xFD, 0x7C, 0x25, 0x9B, 0xE2, 0x16, 0xB2, 0x11, 0x70, 0xD1, 0xE3,
        0xD0, 0x1C, 0xCB, 0xDB, 0x4E, 0x74, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30,
        0x16, 0x80, 0x14, 0xC8, 0x69, 0x00, 0x1E, 0x62, 0xAC, 0x04, 0x36, 0x88, 0xDF, 0xE7, 0xF7, 0xD3,
        0x98, 0xF5, 0x10, 0x7C, 0xE0, 0xF4, 0x3D, 0x30, 0x0A, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D,
        0x04, 0x03, 0x02, 0x03, 0x81, 0x8C, 0x00, 0x30, 0x81, 0x88, 0x02, 0x42, 0x01, 0x7B, 0x3F, 0xB7,
        0xC2, 0x5D, 0xEF, 0x06, 0x05, 0x57, 0x15, 0xA8, 0x51, 0xDF, 0x61, 0x22, 0xB8, 0xB7, 0x63, 0x77,
        0xAE, 0xB7, 0xB6, 0xD5, 0x49, 0xD4, 0x2F, 0x81, 0x0B, 0x31, 0xF0, 0x53, 0xF0, 0xA1, 0x35, 0x2B,
        0x53, 0x9B, 0x1E, 0x7F, 0x5D, 0x01, 0x26, 0xE3, 0xD1, 0x6D, 0xC3, 0xF0, 0x5C, 0x58, 0x6C, 0xF8,
        0x09, 0x7A, 0xF4, 0x85, 0xD4, 0x73, 0x83, 0x8C, 0xC1, 0x41, 0x8B, 0x2D, 0x5B, 0x56, 0x02, 0x42,
        0x01, 0x64, 0x39, 0xAA, 0x61, 0x2D, 0x49, 0x14, 0xE4, 0x50, 0xC8, 0x1C, 0x4C, 0x00, 0x43, 0x0F,
        0x9E, 0xA5, 0xF4, 0x45, 0x2F, 0x01, 0x53, 0x99, 0x05, 0x44, 0x29, 0x9A, 0xC2, 0xB3, 0xED, 0xD6,
        0x9D, 0xC9, 0x42, 0x16, 0x7D, 0xF9, 0xB0, 0xB7, 0x7A, 0xF9, 0x15, 0x6D, 0x75, 0x53, 0x99, 0x55,
        0x41, 0xAE, 0xB9, 0x28, 0x2A, 0xCD, 0x94, 0xB2, 0x9C, 0xA5, 0xF2, 0x01, 0x5E, 0xA3, 0x2E, 0x4C,
        0x63, 0xE9
    };

    // Validate signer cert against its certificate authority (CA) public key
    ret = atcacert_verify_cert_sw(&g_test_p521_cert_def_13_signer, g_p521_signer_cert, sizeof(g_p521_signer_cert), &test_p521_signer_13_ca_public_key);
    TEST_ASSERT_EQUAL(ATCACERT_E_SUCCESS, ret);

    // Get the signer's public key from its certificate
    ret = atcacert_get_subj_public_key(&g_test_p521_cert_def_13_signer, g_p521_signer_cert, sizeof(g_p521_signer_cert), &signer_pubkey);
    TEST_ASSERT_EQUAL(ATCACERT_E_SUCCESS, ret);

    // Validate the device cert against its certificate authority (CA) which is the signer
    ret = atcacert_verify_cert_sw(&g_test_p384_cert_def_14_device, p384_device_cert, sizeof(p384_device_cert), &signer_pubkey);
    TEST_ASSERT_EQUAL(ATCACERT_E_SUCCESS, ret);
}
#endif

TEST(atcacert_host_sw, test_atcacert_verify_cert_sw_bad_sig)
{
    int ret = 0;
    uint8_t bad_cert[sizeof(g_signer_cert)];
    cal_buffer test_signer_1_ca_public_key = CAL_BUF_INIT(ATCA_ECCP256_PUBKEY_SIZE, g_test_signer_1_ca_public_key);

    memcpy(bad_cert, g_signer_cert, sizeof(bad_cert));

    // Change the signature so it doesn't decode
    bad_cert[g_test_cert_def_1_signer.std_cert_elements[STDCERT_SIGNATURE].offset]++;

    // Validate signer cert against its certificate authority (CA) public key
    ret = atcacert_verify_cert_sw(&g_test_cert_def_1_signer, bad_cert, sizeof(bad_cert), &test_signer_1_ca_public_key);
    TEST_ASSERT_EQUAL(ATCACERT_E_DECODING_ERROR, ret);
}

TEST(atcacert_host_sw, test_atcacert_verify_response_sw_success)
{
    ATCA_STATUS status = ATCA_SUCCESS;
    /* Created a SHA2-256 message digest for "Hello World!" */
    uint8_t msg[ATCA_SHA256_DIGEST_SIZE] = {
        0x7f, 0x83, 0xb1, 0x65, 0x7f, 0xf1, 0xfc, 0x53,
        0xb9, 0x2d, 0xc1, 0x81, 0x48, 0xa1, 0xd6, 0x5d,
        0xfc, 0x2d, 0x4b, 0x1f, 0xa3, 0xd6, 0x77, 0x28,
        0x4a, 0xdd, 0xd2, 0x00, 0x12, 0x6d, 0x90, 0x69 }; 
    cal_buffer msg_buf = CAL_BUF_INIT(sizeof(msg), msg);
    uint8_t public_key[ATCA_ECCP256_PUBKEY_SIZE];
    cal_buffer pubkey_buf = CAL_BUF_INIT(sizeof(public_key), public_key);
    uint8_t signature[ATCA_ECCP256_SIG_SIZE];
    cal_buffer sig_buf = CAL_BUF_INIT(sizeof(signature), signature);
    uint16_t private_key_id = 0;

    test_assert_config_is_locked();
    test_assert_data_is_locked();

    status = atca_test_config_get_id(TEST_TYPE_ECC_SIGN, &private_key_id);
    TEST_ASSERT_EQUAL(ATCA_SUCCESS, status);

    /* Load the public key */
    if ((true == atcab_is_ca_device(gCfg->devtype)) || (true == atcab_is_ca2_device(gCfg->devtype)))
    {
#if ATCA_CA_SUPPORT
        status = atcab_get_pubkey(private_key_id, public_key);
#endif
    }
    else
    {
#if ATCA_TA_SUPPORT
        status = talib_get_pubkey(atcab_get_device(), private_key_id, &pubkey_buf);
#endif
    }
    TEST_ASSERT_EQUAL(ATCA_SUCCESS, status);

    /* Sign message */
    if ((true == atcab_is_ca_device(gCfg->devtype)) || (true == atcab_is_ca2_device(gCfg->devtype)))
    {
#if ATCA_CA_SUPPORT
        status = atcab_sign(private_key_id, msg, signature);
#endif
    }
    else
    {
#if ATCA_TA_SUPPORT
        status = talib_sign_external(atcab_get_device(), TA_KEY_TYPE_ECCP256, private_key_id, TA_HANDLE_INPUT_BUFFER, &msg_buf, &sig_buf);
#endif
    }
    TEST_ASSERT_EQUAL(ATCA_SUCCESS, status);

    status = atcacert_verify_response_sw(&pubkey_buf, &msg_buf, &sig_buf);
    TEST_ASSERT_EQUAL(ATCA_SUCCESS, status);
}  

TEST_CONDITION(atcacert_host_sw, verify_resp_cond)
{
    ATCADeviceType dev_type = atca_test_get_device_type();

    return atcab_is_ta_device(dev_type);
}

#if ATCA_TA_SUPPORT
TEST(atcacert_host_sw, test_atcacert_verify_response_sw_p384_success)
{
    int ret = 0;
    uint8_t public_key[] = {
        0xA5, 0x0F, 0x93, 0x34, 0x8E, 0x71, 0x1F, 0xC2, 0xFE, 0x4F, 0xBA, 0xCF, 0xD3, 0xFB, 0xB0, 0x64,
        0xA5, 0x55, 0xB2, 0xB7, 0x3C, 0x82, 0x60, 0xAC, 0x02, 0xAA, 0x04, 0x94, 0x00, 0x2A, 0x77, 0x7F,
        0x6F, 0xA5, 0x64, 0x14, 0x27, 0x6B, 0xA9, 0x2E, 0x54, 0xFD, 0x37, 0x4D, 0x37, 0x83, 0x4C, 0xE5,
        0xF4, 0x70, 0x72, 0x1E, 0xB1, 0x22, 0xD0, 0xAB, 0xF4, 0x57, 0x0A, 0x7F, 0xCF, 0x54, 0x01, 0x25,
        0x19, 0xAC, 0xE5, 0x95, 0x43, 0xAD, 0xFF, 0x2D, 0x87, 0xD1, 0xCE, 0x2D, 0xF6, 0x4D, 0xAF, 0x67,
        0xA4, 0x3D, 0x47, 0x48, 0x39, 0xA8, 0x64, 0x2F, 0xCB, 0x3A, 0x3E, 0x11, 0xCA, 0xDA, 0x4F, 0xB5
    };
    uint8_t challenge_buf[] = {
        0x0c, 0xa6, 0x34, 0xc8, 0x37, 0x2f, 0x87, 0x99, 0x99, 0x7e, 0x9e, 0xe9, 0xd5, 0xbc, 0x72, 0x71,
        0x84, 0xd1, 0x97, 0x0a, 0xea, 0xfe, 0xac, 0x60, 0x7e, 0xd1, 0x3e, 0x12, 0xb7, 0x32, 0x25, 0xf1,
        0x67, 0x20, 0x34, 0x96, 0x67, 0x55, 0x49, 0x72, 0x83, 0x14, 0x5d, 0x13, 0xa1, 0xc2, 0xde, 0x88
    };
    uint8_t response_buf[] = {
        0xDD, 0xC3, 0xFF, 0x62, 0xE8, 0x4A, 0x18, 0x34, 0xC0, 0x83, 0x7D, 0xA8, 0xE9, 0x0B, 0x1D, 0xCB,
        0x83, 0x12, 0x71, 0x3E, 0x80, 0xDF, 0x12, 0xE4, 0xCB, 0x72, 0x9F, 0xC5, 0x4A, 0xC7, 0x2C, 0x2A,
        0x84, 0x8B, 0xD3, 0xBB, 0x9C, 0x16, 0x0F, 0xC9, 0x9D, 0x2C, 0x21, 0x59, 0x19, 0x78, 0xD7, 0xAA,
        0x6B, 0x8D, 0xAA, 0x11, 0x28, 0xF1, 0x83, 0x15, 0xB4, 0x4A, 0xE7, 0xFC, 0x03, 0x81, 0xAC, 0x9B,
        0x5C, 0xC1, 0xFA, 0x81, 0x53, 0x27, 0xA1, 0xAE, 0xB8, 0xCA, 0x9B, 0x2F, 0xFF, 0x24, 0x6B, 0x4B,
        0x69, 0x38, 0xAF, 0x46, 0x4B, 0x3D, 0x94, 0xBD, 0x79, 0xFF, 0xDE, 0xF4, 0x66, 0xF6, 0xA6, 0x79
    };
    cal_buffer pub_key = CAL_BUF_INIT(sizeof(public_key), public_key);
    cal_buffer challenge = CAL_BUF_INIT(sizeof(challenge_buf), challenge_buf);
    cal_buffer response = CAL_BUF_INIT(sizeof(response_buf), response_buf);

    ret = atcacert_verify_response_sw(&pub_key, &challenge, &response);
    TEST_ASSERT_EQUAL(ATCACERT_E_SUCCESS, ret);
}
#endif

TEST(atcacert_host_sw, test_atcacert_verify_response_sw_null_buf)
{
    ATCA_STATUS status;
    uint8_t device_public_key[64] = { 0 };
    cal_buffer pubkey_buf = CAL_BUF_INIT(sizeof(device_public_key), device_public_key);
    uint8_t challenge[32] = { 0 };
    cal_buffer challenge_buf = CAL_BUF_INIT(sizeof(challenge), challenge);
    uint8_t response[64] = { 0 };
    cal_buffer response_buf = CAL_BUF_INIT(sizeof(response), response);
    
    status = atcacert_verify_response_sw(NULL, &challenge_buf, &response_buf);
    TEST_ASSERT_EQUAL(ATCACERT_E_BAD_PARAMS, status);

    status = atcacert_verify_response_sw(&pubkey_buf, NULL, &response_buf);
    TEST_ASSERT_EQUAL(ATCACERT_E_BAD_PARAMS, status);

    status = atcacert_verify_response_sw(&pubkey_buf, &challenge_buf, NULL);
    TEST_ASSERT_EQUAL(ATCACERT_E_BAD_PARAMS, status);

}
#endif /* ATCAC_VERIFY_EN */

#if ATCAC_RANDOM_EN
TEST(atcacert_host_sw, test_atcacert_gen_challenge_sw_null_challenge)
{
    ATCA_STATUS status;
    status = atcacert_gen_challenge_sw(NULL);
    TEST_ASSERT_EQUAL(ATCA_BAD_PARAM, status);
}

TEST(atcacert_host_sw, test_atcacert_gen_challenge_sw_success)
{
    uint8_t challenge[32];
    cal_buffer challenge_buf = CAL_BUF_INIT(sizeof(challenge), challenge);
    ATCA_STATUS status;
    status = atcacert_gen_challenge_sw(&challenge_buf);
    TEST_ASSERT_EQUAL(ATCA_SUCCESS, status);
}
#endif /* ATCAC_RANDOM_EN */

#if ATCACERT_COMPCERT_EN && ATCAC_CERT_ADD_EN
TEST(atcacert_host_sw, test_atcacert_cert_add)
{
    int ret;
    uint8_t sw_cert[1024];
    ATCADeviceType dev_type = atcab_get_device_type();

    if (atcab_is_ca_device(dev_type))
    {
        ret = atcacert_cert_add((void *)&sw_cert, &g_test_cert_def_0_device);
    }

    TEST_ASSERT_EQUAL(ATCA_SUCCESS, ret);

}

#if ATCA_TA_SUPPORT && ATCAC_SHA384_EN && ATCAC_SHA512_EN 

uint8_t g_signer_p521_ca_public_key_crt_add[ATCA_ECCP521_PUBKEY_SIZE];
uint8_t g_signer_p521_public_key_crt_add[ATCA_ECCP521_PUBKEY_SIZE];
uint8_t g_device_p384_public_key_crt_add[ATCA_ECCP384_PUBKEY_SIZE];
uint16_t g_signer_ca_p521_private_key_slot_crt_add = 0;

uint8_t g_signer_cert_ref_crt_add[612];
size_t g_signer_cert_ref_crt_add_size = 0;

uint8_t g_device_cert_ref_crt_add[612];
size_t g_device_cert_ref_crt_add_size = 0;

TEST_CONDITION(atcacert_host_sw, ta_cert_add_test_condn)
{
    ATCADeviceType dev_type = atca_test_get_device_type();

    return (TA101 == dev_type);
}

TEST(atcacert_host_sw, test_atcacert_cert_add_ta)
{
    int ret = 0;
    uint8_t signer_id[2] = { 0xC4, 0x8B };
    const atcacert_tm_utc_t signer_issue_date = {
        .tm_year    = 2025 - 1900,
        .tm_mon     = 1 - 1,
        .tm_mday    = 18,
        .tm_hour    = 20,
        .tm_min     = 0,
        .tm_sec     = 0
    };
    const atcacert_tm_utc_t device_issue_date = {
        .tm_year    = 2025 - 1900,
        .tm_mon     = 1 - 1,
        .tm_mday    = 20,
        .tm_hour    = 20,
        .tm_min     = 0,
        .tm_sec     = 0
    };
    uint8_t sn[8];
    cal_buffer signer_p521_ca_public_key = CAL_BUF_INIT(sizeof(g_signer_p521_ca_public_key_crt_add), g_signer_p521_ca_public_key_crt_add);
    cal_buffer signer_p521_public_key = CAL_BUF_INIT(sizeof(g_signer_p521_public_key_crt_add), g_signer_p521_public_key_crt_add);
    cal_buffer device_p384_public_key = CAL_BUF_INIT(sizeof(g_device_p384_public_key_crt_add), g_device_p384_public_key_crt_add);

#if TALIB_CREATE_SHARED_DATA_EN
    ta_element_attributes_t attr_priv_key_handle;
    ta_element_attributes_t data_attr;
    uint16_t compressed_signer_cert_handle = 0x8800;
    uint16_t compressed_device_cert_handle = 0x8801;
#endif
    uint16_t signer_p521_private_key_slot = 0;
    uint16_t device_p384_private_key_slot = 0;

    uint8_t sw_cert[1024];
    ATCADeviceType dev_type = atcab_get_device_type();

    // Create the p521 private key handle for the Root CA
#if TALIB_CREATE_SHARED_DATA_EN
    ret = talib_handle_init_private_key(&attr_priv_key_handle, TA_KEY_TYPE_ECCP521, TA_ALG_MODE_ECC_ECDSA,
                                        TA_PROP_SIGN_INT_EXT_DIGEST, TA_PROP_NO_KEY_AGREEMENT);
    TEST_ASSERT_EQUAL(ATCA_SUCCESS, ret);

    ret = talib_create_element(atcab_get_device(), &attr_priv_key_handle, &g_signer_ca_p521_private_key_slot_crt_add);
    TEST_ASSERT_EQUAL(ATCA_SUCCESS, ret);
#endif
    // Generate the private and public keypair for the eccp521 Root CA
    ret = atca_test_genkey(atcab_get_device(), g_signer_ca_p521_private_key_slot_crt_add, &signer_p521_ca_public_key);
    TEST_ASSERT_EQUAL(ATCA_SUCCESS, ret);

    // Get the p521 private key handle for the Signer Cert
    ret = atca_test_config_get_id(TEST_TYPE_EC_P521_SIGN, &signer_p521_private_key_slot);
    TEST_ASSERT_EQUAL(ATCA_SUCCESS, ret);

    // Generate the private and public keypair for the eccp521 Signer Cert
    ret = atca_test_genkey(atcab_get_device(), signer_p521_private_key_slot, &signer_p521_public_key);
    TEST_ASSERT_EQUAL(ATCA_SUCCESS, ret);

    // Get the p384 private key handle for the Device Cert
    ret = atca_test_config_get_id(TEST_TYPE_EC_P384_SIGN, &device_p384_private_key_slot);
    TEST_ASSERT_EQUAL(ATCA_SUCCESS, ret);

    // Generate the private and public keypair for the eccp384 Device Cert
    ret = atca_test_genkey(atcab_get_device(), device_p384_private_key_slot, &device_p384_public_key);
    TEST_ASSERT_EQUAL(ATCA_SUCCESS, ret);

    // Create data handle to store compressed certificate
#if TALIB_CREATE_SHARED_DATA_EN
    ret = talib_handle_init_data(&data_attr, ATCACERT_COMP_CERT_MAX_SIZE);
    TEST_ASSERT_EQUAL(ATCA_SUCCESS, ret);

    ret = talib_create_element_with_handle(atcab_get_device(), compressed_signer_cert_handle, &data_attr);
    TEST_ASSERT_EQUAL(ATCA_SUCCESS, ret);

    ret = talib_create_element_with_handle(atcab_get_device(), compressed_device_cert_handle, &data_attr);
    TEST_ASSERT_EQUAL(ATCA_SUCCESS, ret);
#endif

    // Read the serial number from the device
    ret = talib_info_serial_number(atcab_get_device(), sn);
    TEST_ASSERT_EQUAL(ATCA_SUCCESS, ret);

    // Build signer cert
    g_signer_cert_ref_crt_add_size = sizeof(g_signer_cert_ref_crt_add);
    build_and_save_cert_ta(
        &g_test_p521_cert_def_13_signer,
        g_signer_cert_ref_crt_add,
        &g_signer_cert_ref_crt_add_size,
        &signer_p521_ca_public_key,
        &signer_p521_public_key,
        signer_id,
        &signer_issue_date,
        sn,
        g_signer_ca_p521_private_key_slot_crt_add);

    // Build Device cert
    g_device_cert_ref_crt_add_size = sizeof(g_device_cert_ref_crt_add);
    build_and_save_cert_ta(
        &g_test_p384_cert_def_14_device,
        g_device_cert_ref_crt_add,
        &g_device_cert_ref_crt_add_size,
        &signer_p521_public_key,
        &device_p384_public_key,
        signer_id,
        &device_issue_date,
        sn,
        signer_p521_private_key_slot);

    // Test sw cert chain add
    if (atcab_is_ta_device(dev_type))
    {
        ret = atcacert_cert_add((void *)&sw_cert, &g_test_p384_cert_def_14_device);
    }

    TEST_ASSERT_EQUAL(ATCA_SUCCESS, ret);

#if TALIB_DELETE_EN
    ret = talib_delete_handle(atcab_get_device(), g_signer_ca_p521_private_key_slot_crt_add);
    TEST_ASSERT_EQUAL(ATCA_SUCCESS, ret);

    ret = talib_delete_handle(atcab_get_device(), compressed_signer_cert_handle);
    TEST_ASSERT_EQUAL(ATCA_SUCCESS, ret);

    ret = talib_delete_handle(atcab_get_device(), compressed_device_cert_handle);
    TEST_ASSERT_EQUAL(ATCA_SUCCESS, ret);
#endif

}
#endif /* ATCA_TA_SUPPORT && ATCAC_SHA384_EN && ATCAC_SHA512_EN */
#endif /* ATCACERT_COMPCERT_EN && ATCAC_CERT_ADD_EN */

#endif /* ATCA_HOSTLIB_EN */

t_test_case_info atcacert_host_sw_tests[] =
{
#if ATCA_HOSTLIB_EN
#if ATCAC_VERIFY_EN
    { REGISTER_TEST_CASE(atcacert_host_sw, test_atcacert_verify_cert_sw_success),          NULL },
#if ATCA_TA_SUPPORT && ATCAC_SHA384_EN && ATCAC_SHA512_EN
    { REGISTER_TEST_CASE(atcacert_host_sw, test_atcacert_verify_cert_sw_p521_signer_p384_device), REGISTER_TEST_CONDITION(atcacert_host_sw, verify_chain_cond) },
#endif
    { REGISTER_TEST_CASE(atcacert_host_sw, test_atcacert_verify_cert_sw_bad_sig),          NULL },
    { REGISTER_TEST_CASE(atcacert_host_sw, test_atcacert_verify_response_sw_success),      NULL },
#if ATCA_TA_SUPPORT
    { REGISTER_TEST_CASE(atcacert_host_sw, test_atcacert_verify_response_sw_p384_success), REGISTER_TEST_CONDITION(atcacert_host_sw, verify_resp_cond) },
#endif
    { REGISTER_TEST_CASE(atcacert_host_sw, test_atcacert_verify_response_sw_null_buf),     NULL },   
#endif
#if ATCAC_RANDOM_EN
    { REGISTER_TEST_CASE(atcacert_host_sw, test_atcacert_gen_challenge_sw_null_challenge), NULL },
    { REGISTER_TEST_CASE(atcacert_host_sw, test_atcacert_gen_challenge_sw_success),        NULL },
#endif
#if ATCACERT_COMPCERT_EN
    { REGISTER_TEST_CASE(atcacert_host_sw, test_atcacert_cert_add),                        atca_test_cond_ecc608 },
#if ATCA_TA_SUPPORT && ATCAC_SHA384_EN && ATCAC_SHA512_EN
    { REGISTER_TEST_CASE(atcacert_host_sw, test_atcacert_cert_add_ta),                     REGISTER_TEST_CONDITION(atcacert_host_sw, ta_cert_add_test_condn) },
#endif
#endif
#endif
    /* Array Termination element*/
    { (fp_test_case)NULL, NULL },
};
